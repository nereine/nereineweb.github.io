<!DOCTYPE html><html> <head><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=keywords content=Eine><meta name=author content=@eine><meta charset=UTF-8><link rel=stylesheet type=text/css href=/style.css><link rel=stylesheet type=text/css href=style.css><title>NerEine.com</title></head> <body> <ul class=navbar> <li><a href=/ >HOME</a></li> <li class=f-right><a href=https://searx.nereine.com>Search</a></li> <li class=f-right><a href=/blog/ >Blog</a></li> </ul> <p>24 Aug <a href=/blog/2022/ >2022</a></p> <h1 id=time-series-data-testing-stationary-non-stationary-via-python>Time series data testing (Stationary &#38; Non-stationary) via Python</h1> <p>ในบทความนี้เราจะมาเล่าถึงวิธีการทดสอบข้อมูลอนุกรมเวลา หรือ Time series data เพื่อใช้สำหรับการพยากรณ์ตัวเลขทางสถิติ</p> <p>สำหรับข้อมูลอนุกรมเวลา ก่อนที่เราจะนำไปเข้าโมเดลแบบจำลองเพื่อพยากรณ์ตัวแปรต่างๆได้นั้น มีความจำเป็นอย่างยิ่งที่จะต้องทำการทดสอบก่อนว่า ข้อมูลดังกล่าวมีลักษณะนิ่ง (Stationary) หรือไม่ ถ้าข้อมูลมีลักณะนิ่ง ถึงจะสามารถนำข้อมูลดังกล่าวไปทำการพยากรณ์ได้ในแบบจำลองต่างๆ ที่กำหนดไว้</p> <p>อย่างไรก็ตาม คุณลักษณะของข้อมูล Time series ที่มีลักษณะนิ่งนั้นจะต้องประกอบไปด้วยคุณลักษณะ 3 ประการ ตามสมการที่กำหนดไว้ ดังนี้</p> <pre><code>E(Yt) = μ           (1.)
</code></pre> <p>(1.) ค่าเฉลี่ยของข้อมูลอนุกรมเวลา Yt จะต้องมีค่าคงที่เมื่อเวลาเปลี่ยนแปลงไป</p> <pre><code>Var(Yt) = E(Yt - μ)^2 = σ^2         (2.)
</code></pre> <p>(2.) ค่าความแปรปรวนของข้อมูลอนุกรมเวลา Yt จะต้องมีค่าคงที่เมื่อเวลาเปลี่ยนแปลงไป และ</p> <pre><code>E[(Yt - μ)(Yt+k - μ)] = Υk          (3.)
</code></pre> <p>(3.) ค่าความแปรปรวนร่วมของข้อมูลอนุกรมเวลา Yt จะต้องมีการเปลี่ยนแปลงไปแค่ใน 2 ช่วงเวลาเท่านั้น</p> <p>ในทางกลับกันถ้าข้อมูลมีลักษณะไม่นิ่ง (Non-stationary) แสดงว่า ค่าเฉลี่ยของข้อมูลอนุกรมเวลา Yt จะมีค่าเปลี่ยนแปลงไปเมื่อเวลาเปลี่ยนแปลงไป ค่าความแปรปรวนของข้อมูลอนุกรมเวลา Yt จะมีค่าเปลี่ยนแปลงไปเมื่อเวลาเปลี่ยนแปลง และ ค่าความแปรปรวนร่วมของข้อมูลอนุกรมเวลา Yt จะมีการเปลี่ยนแปลงไปมากกว่่าใน 2 ช่วงเวลา ดังนี้</p> <pre><code>E(Yt) = tμ
Var(Yt) = E(Yt - μ)^2 = tσ^2
E[(Yt - μ)(Yt+k - μ)] = tΥk
</code></pre> <p>หลังจากที่กล่าวมาในข้างต้น ทำให้เราทราบได้ถึงความแตกต่างของข้อมูลอนุกรมเวลา หรือ Time series data ระหว่างข้อมูลที่มีลักษณะนิ่ง (Stationary) และข้อมูลที่มีลักษณะไม่นิ่ง (Non-stationary) ทั้งนี้ ในส่วนถัดไปเราจะเข้าสู่เนื้อหาหลักของบทความนี้ นั่นคือ การทดสอบความนิ่งของข้อมูลที่ใช้ในการพยากรณ์ หรือที่เรียกว่า Unit root test</p> <h2 id=unit-root-test>Unit root test</h2> <p>โดยการทดสอบความนิ่งของข้อมูลที่ใช้ในการพยากรณ์นี้มีอยู่หลากหลายวิธี ไม่ว่าจะเป็น ADF-Test, PP-Test, KPSS Test, and etc. ซึ่งในบทความนี้จะเลือกวิธีการทดสอบแบบ ADF-Test (Augmented Dickey-Fuller test, Dickey, D.A. and W.A. Fuller (1979))</p> <p>ในขั้นตอนแรก เราจำเป็นที่จะต้องมี library ที่ชื่อว่า <code>statmodels</code> ก่อน แต่ถ้ายังเราก็แค่พิมพ์ <code>command</code> ลงใน Terminal ดังนี้:</p> <pre><code>pip install statsmodels
</code></pre> <p>หลังจากที่ติดตั้ง library <code>statsmodels</code> เป็นที่เรียบร้อยแล้ว เราก็จะ import library ดังนี้:</p> <pre><code>import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.tsa.stattools as adfuller
</code></pre> <p>ถัดมา เราจะ import ข้อมูลที่เราต้องการใช้เพื่อทดสอบความเป็น Stationary หรือ Non-stationary โดยข้อมูลที่จะยกตัวอย่างนั้นเป็นข้อมูลตัวเลขทางเศรษฐกิจ คือ ดัชนีผลผลิตอุตสาหกรรม หรือ <code>mpi_th</code> และจัดเรียง data ให้สวยงาม:</p> <pre><code>date_index = pd.date_range(start=&#39;2011-01-01&#39;, end=&#39;2022-05-01&#39;, freq=&#39;M&#39;)
data = pd.read_csv(&#39;mpi_th.csv&#39;, parse_dates=[&#39;date&#39;])
df = pd.DataFrame(data)
df[&#39;date&#39;] = date_index
df = df.set_index(&#39;date&#39;)
df
</code></pre> <p>และสุดท้าย เราจะสร้างฟังก์ชันเพื่อทดสอบ ADF-Test และ plot ข้อมูล ดังนี้:</p> <pre><code>def ad_test(dataset):
    # ADF-Test:
    dftest = adfuller(dataset, autolag= &#39;AIC&#39;)
    print(&#39;1. ADF Statistic:&#39;, dftest[0])
    print(&#39;2. p-value:&#39;, dftest[1])
    print(&#39;3. Num of Lags:&#39;, dftest[2])
    print(&#39;4. Num of Observations Used For ADF Regression and Critical Values Calculation:&#39;, dftest[3])
    print(&#39;5. Critical Values:&#39;)
    for key, value in dftest[4].items():
        print(&#39;\t{}: {}&#39;.format(key, value))
    return dftest

def get_stationarity(dataset):
    # Rolling Statistics
    rolling_mean = dataset.rolling(window=12).mean()
    rolling_std = dataset.rolling(window=12).std()
    # Rolling Statistics Plot
    original = plt.plot(dataset, color=&#39;blue&#39;, label=&#39;MPI_TH&#39;)
    mean = plt.plot(rolling_mean, color=&#39;red&#39;, label=&#39;Rolling Mean&#39;)
    std = plt.plot(rolling_std, color=&#39;black&#39;, label=&#39;Rolling Std&#39;)
    plt.legend(loc=&#39;best&#39;)
    plt.title(&#39;Rolling Mean &#38; Standard Deviation&#39;)
    plt.show(block=False)
    # Dickey–Fuller Test 
    result = ad_test(dataset)
    return original, mean, std, result
</code></pre> <p>หลังจากนั้น เราก็จะได้ <code>output</code> ดังนี้:</p> <p><img src=mpi_th_adf.png alt=image.png></p> <pre><code>1. ADF Statistic: -3.737635625012291
2. p-value: 0.003613862916598776
3. Num of Lags: 12
4. Num of Observations Used For ADF Regression and Critical Values Calculation: 123
5. Critical Values:
    1%: -3.4846672514209773
    5%: -2.8853397507076006
    10%: -2.5794629869786503
</code></pre> <p>จากการทดสอบ ADF-Test และมีผลลัพธ์ตามข้างต้น จะพบว่า สามารถปฏิเสธสมมุติฐานหลักได้ (Ho) นั้นหมายถึงข้อมูลดังกล่าวมีลักษณะเป็น Stationary หรือมีลักษณะนิ่ง กล่าวคือ ค่า Parameter Υ ในแบบจำลอง ADF-Test มีนัยสำคัญทางสถิติ (statistical significance) ที่ 90% ขึ้นไปจึงต้องปฏิเสธสมมุติฐาน Ho</p> <hr> </body> <footer> <p>All rights reserved. NerEine@2020</p> </footer> </html> 